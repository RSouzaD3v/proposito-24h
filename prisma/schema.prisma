generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/** Papéis */
enum Role {
  ADMIN        // Admin master (writerId opcional)
  WRITER_ADMIN // Admin/gestor da instância (writerId obrigatório)
  CLIENT       // Usuário final (writerId obrigatório)
}

/** Publicação pode ser um Devocional (página única) ou um Ebook (com capítulos) */
enum PublicationType {
  DEVOTIONAL   // página única (title/subtitle/description + cover)
  EBOOK        // múltiplos capítulos
}

enum PublicationStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum Visibility {
  FREE
  PAID         // se PAID, exige compra para acessar conteúdo completo
}

enum PurchaseStatus {
  SUCCESS
  PENDING
  FAILED
}

/** Provedor de pagamento (por enquanto só Stripe) */
enum PaymentProvider {
  STRIPE
}

enum PayoutStatus {
  PENDING
  PAID
  CANCELED
}

model Writer {
  id             String   @id @default(uuid())
  name           String
  slug           String   @unique
  logoUrl        String?
  colorPrimary   String?
  colorSecondary String?

  // Configurações white label
  branding       Json?
  socials        Json?
  storagePrefix  String?
  emailFrom      String?
  featureFlags   Json?

  stripeAccountId String?
  stripeCustomerId String?

  domains        Domain[]
  publications   Publication[]
  users          User[]
  purchases      Purchase[]
  payouts        WriterPayout[]
  subscriptions WriterSubscription[]
  quotes         Quote[]
  devotionals    Devotional[]
  verses         Verse[]
  prayers       Prayer[]

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model WriterSubscription {
  id         String   @id @default(uuid())
  writerId   String
  writer     Writer   @relation(fields: [writerId], references: [id])
  startedAt  DateTime @default(now())
  endedAt    DateTime
  amount     Float
  description String?
  stripeId   String? @unique
  stripe     Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Domain {
  id        String  @id @default(uuid())
  host      String  @unique  // ex: igreja1.seudominio.com ou dominio-proprio.com
  subdomain String  @unique
  writerId  String
  writer    Writer  @relation(fields: [writerId], references: [id])
  isPrimary Boolean @default(false)
}

model User {
  id         String    @id @default(uuid())
  email      String    @unique
  name       String?
  password   String
  role       Role      @default(CLIENT)

  // Para ADMIN pode ser null; para WRITER_ADMIN/CLIENT deve apontar p/ o writer
  writerId   String?
  writer     Writer?   @relation(fields: [writerId], references: [id])

  purchases  Purchase[]
  clientSubscriptions ClientSubscription[]

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  userCompletationQuote UserCompletationQuote[]
  userCompletationDevotional UserCompletationDevotional[]
  userCompletationVerse UserCompletationVerse[]
  userCompletationPrayer UserCompletationPrayer[]
}

model ClientSubscription {
  id         String   @id @default(uuid())
  clientId   String
  client     User   @relation(fields: [clientId], references: [id])
  startedAt  DateTime @default(now())
  endedAt    DateTime
  amount     Float
  description String?
  stripeCustomerId String? @unique
  stripeSubscriptionId String? @unique
  stripeId   String? @unique
  stripe     Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}


model Prayer {
  id String @id @default(uuid())
  title String
  content String
  writerId String
  writer   Writer @relation(fields: [writerId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userCompletationPrayer UserCompletationPrayer[]
}

model UserCompletationPrayer {
  id String @id @default(uuid())
  userId String
  user   User @relation(fields: [userId], references: [id])
  prayerId String
  prayer   Prayer @relation(fields: [prayerId], references: [id])
}

/**
 * PUBLICATION = unidade editorial publicável e vendável.
 * - DEVOTIONAL: página única (usa os campos de corpo na própria Publication)
 * - EBOOK: metadados na Publication e conteúdo distribuído em Chapter(s)
 */
model Publication {
  id            String            @id @default(uuid())
  writerId      String
  writer        Writer            @relation(fields: [writerId], references: [id])

  type          PublicationType
  status        PublicationStatus @default(DRAFT)
  visibility    Visibility        @default(FREE)

  // monetização (se visibility = PAID)
  price         Int?              // em centavos (opcional)
  currency      String?           // ex: "BRL"
  stripeProductId String?         // <--- novo
  stripePriceId   String?         // <--- novo

  // SEO / rota
  slug          String            // único por writer
  @@unique([writerId, slug])

  // metadados editoriais
  title         String
  subtitle      String?
  description   String?
  category     String? @default("Religioso")           // ex: "Espiritualidade", "Família"

  // capa da publicação
  coverUrl      String?

  // Conteúdo direto (para DEVOTIONAL página única)
  // Para EBOOK normalmente fica vazio e o conteúdo vem de Chapter(s)
  body          String?           // markdown/HTML/JSON (defina no app)

  // Organização
  tags          String[]          // opcional: ["oração","família"]
  publishedAt   DateTime?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  chapters      Chapter[]
  purchases     Purchase[]
}

/**
 * CHAPTER = capítulo de um ebook.
 * - Possui ordem, imagem própria opcional e conteúdo.
 */
model Chapter {
  id             String       @id @default(uuid())
  publicationId  String
  publication    Publication  @relation(fields: [publicationId], references: [id])

  order          Int          // índice/ordem do capítulo (0..n)
  title          String
  subtitle       String?
  coverUrl       String?      // imagem do capítulo (opcional)
  content        String       // markdown/HTML/JSON

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
}

/**
 * Purchase centralizada no Admin Master (Stripe).
 * Mantém campos para conciliação, taxas e recibos.
 */
model Purchase {
  id                     String          @id @default(uuid())
  userId                 String
  user                   User            @relation(fields: [userId], references: [id])

  publicationId          String
  publication            Publication     @relation(fields: [publicationId], references: [id])

  // redundância útil p/ relatórios rápidos por writer
  writerId               String
  writer                 Writer          @relation(fields: [writerId], references: [id])

  // Valores
  amount                 Int             // bruto em centavos
  currency               String          @default("BRL")
  fees                   Int?            // taxas do provedor (centavos)
  netAmount              Int?            // líquido (amount - fees - impostos)

  status                 PurchaseStatus
  provider               PaymentProvider @default(STRIPE)

  // Referências Stripe p/ conciliação
  stripeSessionId        String?   // checkout session
  stripePaymentIntentId  String?
  stripePaymentMethodId  String?
  stripeChargeId         String?
  stripeInvoiceId        String?
  stripeCustomerId       String?
  receiptUrl             String?

  rawProviderPayload     Json?     // payload do webhook (opcional)

  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  @@index([writerId, createdAt])
  @@index([publicationId, createdAt])
}

/**
 * Registro de repasses do Admin Master para cada escritor.
 * Pode ser gerado por período (ex.: mensal).
 */
model WriterPayout {
  id           String       @id @default(uuid())
  writerId     String
  writer       Writer       @relation(fields: [writerId], references: [id])

  periodStart  DateTime
  periodEnd    DateTime

  grossAmount  Int          // escolha: soma de netAmount ou amount conforme sua regra
  fees         Int?         // tarifas bancárias do repasse (se houver)
  netAmount    Int          // total a pagar ao escritor
  status       PayoutStatus @default(PENDING)

  // Referências externas (comprovante, txid Pix, etc.)
  reference    String?
  receiptUrl   String?

  notes        String?
  createdAt    DateTime     @default(now())
  paidAt       DateTime?
  updatedAt    DateTime     @updatedAt

  @@index([writerId, periodStart, periodEnd])
}

// CITAÇÃO, DEVOCIONAL, PASSAGEM
model Quote {
  id String @id @default(uuid())
  nameAuthor String
  content String
  verse String
  imageUrl String?
  writerId String
  writer Writer @relation(fields: [writerId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userCompletation UserCompletationQuote[]

  @@index([writerId, createdAt])
}

model UserCompletationQuote {
  id String @id @default(uuid())
  userId String
  user User @relation(fields: [userId], references: [id])
  quoteId String
  quote Quote @relation(fields: [quoteId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Devotional {
  id String @id @default(uuid())
  title String
  content String
  verse String
  imageUrl String?
  writerId String
  writer Writer @relation(fields: [writerId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userCompletation UserCompletationDevotional[]
  @@index([writerId, createdAt])
}

model UserCompletationDevotional {
  id String @id @default(uuid())
  userId String
  user User @relation(fields: [userId], references: [id])
  devotionalId String
  devotional Devotional @relation(fields: [devotionalId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Verse {
  id String @id @default(uuid())
  content String
  reference String
  writerId String
  writer Writer @relation(fields: [writerId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userCompletationVerse UserCompletationVerse[]
  @@index([writerId, createdAt])
}

model UserCompletationVerse {
  id String @id @default(uuid())
  userId String
  user User @relation(fields: [userId], references: [id])
  verseId String
  verse Verse @relation(fields: [verseId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Biblia
model BibleVersion {
  id        String   @id @default(uuid())
  code      String   @unique   // "ACF"
  name      String             // "Almeida Corrigida Fiel"
  language  String             // "pt-BR"
  createdAt DateTime @default(now())
  verses    BibleVerse[]
}

model BibleBook {
  id        Int      @id       // 1..66
  abbrev    String   @unique   // "gn", "mt", ...
  name      String              // "Gênesis", ...
  order     Int      @unique   // posição canônica
  createdAt DateTime @default(now())
  verses    BibleVerse[]

  @@index([order])
}

model BibleVerse {
  id         String       @id @default(uuid())
  versionId  String
  bookId     Int
  chapter    Int
  verse      Int
  text       String

  version    BibleVersion @relation(fields: [versionId], references: [id])
  book       BibleBook    @relation(fields: [bookId], references: [id])

  createdAt  DateTime     @default(now())

  @@unique([versionId, bookId, chapter, verse]) // 1 versículo por versão
  @@index([bookId, chapter, verse])
  @@index([versionId])
}
